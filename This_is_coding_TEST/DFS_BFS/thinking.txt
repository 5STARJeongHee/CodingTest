dfs는 노드가 스택을 이용한 방식 -> 재귀함수는 함수를 스택에 쌓아서 불러옴 
dfs를 구현하는데 아주 적절 -> 스택에 시작 노드로부터 아주 멀리 있는 노드를 우선적
으로 처리(가까운 노드부터 멀리있는 노드를 채워놓고 끝에부터 처리하니까)

freezing juice 는 dfs 문제로 처음보면 어떻게 dfs인지 감잡기도 어려움
그래프 문제임을 파악했고, 탐색을 해야한다고 생각되었다면 dfs나 bfs를 생각해보자



bfs는 큐를 이용한 방식
시작노드로부터 아주 가까이 있는 노드부터 탐색(가까이 있는 노드부터 멀리있는 노드를 채우면서
앞에 있는 노드부터 처리하니까)
dfs나 bfs나 모든 노드를 방문하며 방문처리가 필요하단 점 기억하자

dfs bfs 비교
1. dfs
장점:
- 현 경로상의 노드를 기억하기 때문에 적은 메모리를 사용합니다.
- 찾으려는 노드가 깊은 단계에 있는 경우 BFS 보다 빠르게 찾을 수 있습니다.
단점:
- 해가 없는 경로를 탐색 할 경우 단계가 끝날 때까지 탐색합니다. 효율성을 높이기 위해서 미리 지정한 임의 깊이까지만 탐색하고 해를 발견하지 못하면 빠져나와 다른 경로를 탐색하는 방법을 사용합니다.
- DFS를 통해서 얻어진 해가 최단 경로라는 보장이 없습니다. DFS는 해에 도착하면 탐색을 종료하기 때문입니다.
2. bfs
쓰임:
- 웹 크롤링 - 동적으로 생성되는 무한한 인터넷 페이지를 구글이 크롤링 하기 위해서는 BFS를 합니다.
- 네트워크 브로드캐스트
- 가비지 컬렉션
장점:
- 답이 되는 경로가 여러 개인 경우에도 최단경로임을 보장한다.
- 최단 경로가 존재하면 깊이가 무한정 깊어진다고 해도 답을 찾을 수 있다.

단점:
- 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요로 하게 된다.
- 해가 존재하지 않는다면 유한 그래프(finite graph)의 경우에는 모든 그래프를 탐색한 후에 실패로 끝난다.
- 무한 그래프(infinite graph)의 경우에는 결코 해를 찾지도 못하고, 끝내지도 못한다.